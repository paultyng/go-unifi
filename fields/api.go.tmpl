{{- $structName := .StructName }}

{{ define "field" }}
	{{ .FieldName }} {{ if .IsArray }}[]{{end}}{{ .FieldType }} `json:"{{ .JSONName }}{{ if .OmitEmpty }},omitempty{{ end }}"` {{ if .FieldValidation }}// {{ .FieldValidation }}{{ end }} {{- end }}
{{ define "field-emptyStringInt" }}
	{{- if ne .FieldType "int" }}{{else}}
	    {{ .FieldName }} {{ if .IsArray }}[]{{end}}emptyStringInt `json:"{{ .JSONName }}{{ if .OmitEmpty }}{{ end }}"`{{ end }} {{- end }}
{{ define "field-numberOrString" }}
	{{- /* this is kind of a hack, probably a better way to do this when looking at the normalized validation */ -}}
	{{- if and (eq .FieldType "string") (or (eq .JSONName "channel") (eq .JSONName "backup_channel") (eq .JSONName "tx_power")) }}
	    {{ .FieldName }} {{ if .IsArray }}[]{{end}}numberOrString `json:"{{ .JSONName }}{{ if .OmitEmpty }}{{ end }}"`{{ end }} {{- end }}
{{ define "typecast" }}
    {{- if eq .FieldType "int" }}{{- if .IsArray }}
    dst.{{ .FieldName }}= make([]int, len(aux.{{ .FieldName }}))
    for i, v := range aux.{{ .FieldName }} {
        dst.{{ .FieldName }}[i] = int(v)
    }
    {{- else }}
    dst.{{ .FieldName }} = int(aux.{{ .FieldName }})
    {{- end }}{{- end }}{{- end }}
{{ define "field-embed" }}
	{{ .FieldName }} {{ if .IsArray }}[]{{end}}{{ if not .Fields }}{{ .FieldType }}{{ else }}struct {
	{{ range $fk, $fv := .Fields }}{{ if not $fv }}
	{{ else }}{{- template "field-embed" $fv }}{{ end }}{{ end }}
}{{ end }} `json:"{{ .JSONName }}{{ if .OmitEmpty }},omitempty{{ end }}"` {{ if .FieldValidation }}// {{ .FieldValidation }}{{ end }} {{- end }}
// Code generated from ace.jar fields *.json files
// DO NOT EDIT.

package unifi

import (
	"context"
	"encoding/json"
	"fmt"
)

// just to fix compile issues with the import
var (
	_ context.Context
	_ fmt.Formatter
	_ json.Marshaler
)

{{ if embedTypes -}}
{{- $k := .StructName -}}
{{- $v :=index .Types .StructName -}}
type {{ $k }} struct {
	{{ range $fk, $fv := $v.Fields }}{{ if not $fv }}
	{{ else }}{{- template "field-embed" $fv }}{{ end }}{{ end }}
}
{{- else -}}
{{ range $k, $v := .Types }}
type {{ $k }} struct {
	{{ range $fk, $fv := $v.Fields }}{{ if not $fv }}
	{{ else }}{{- template "field" $fv }}{{ end }}{{ end }}
}

func (dst *{{ $k }}) UnmarshalJSON(b []byte) error {
	type Alias {{ $k }}
	aux := &struct {
	    {{- range $fk, $fv := $v.Fields }}{{ if not $fv }}
	    {{- else }}{{- template "field-emptyStringInt" $fv }}{{- template "field-numberOrString" $fv }}{{ end }}{{- end }}

		*Alias
	}{
		Alias: (*Alias)(dst),
	}

	err := json.Unmarshal(b, &aux)
	if err != nil {
		return fmt.Errorf("unable to unmarshal alias: %w", err)
	}

    {{- range $fk, $fv := $v.Fields }}{{ if not $fv }}
    {{- else }}{{- template "typecast" $fv }}{{ end }}{{ end }}

	return nil
}
{{ end }}
{{- end -}}

{{ if not .IsSetting }}
func (c *Client) list{{ .StructName }}(ctx context.Context, site string) ([]{{ .StructName }}, error) {
	var respBody struct {
		Meta meta `json:"meta"`
		Data []{{ .StructName }} `json:"data"`
	}

	err := c.do(ctx, "GET", fmt.Sprintf("s/%s/{{ if eq .StructName "Device" }}stat/{{else if eq .StructName "APGroup" }}{{ else }}rest/{{ end }}{{ .ResourcePath }}", site), nil, &respBody)
	if err != nil {
		return nil, err
	}

	return respBody.Data, nil
}
{{- end }}

func (c *Client) get{{ .StructName }}(ctx context.Context, site{{ if not .IsSetting }}, id{{ end }} string) (*{{ .StructName }}, error) {
	var respBody struct {
		Meta meta `json:"meta"`
		Data []{{ .StructName }} `json:"data"`
	}
{{ if .IsSetting }}
	err := c.do(ctx, "GET", fmt.Sprintf("s/%s/get/setting/{{ .ResourcePath }}", site), nil, &respBody)
{{- else }}
	err := c.do(ctx, "GET", fmt.Sprintf("s/%s/{{ if eq .StructName "Device" }}stat{{ else }}rest{{ end }}/{{ .ResourcePath }}/%s", site, id), nil, &respBody)
{{- end }}
	if err != nil {
		return nil, err
	}

	if len(respBody.Data) != 1 {
		return nil, &NotFoundError{}
	}

	d := respBody.Data[0]
	return &d, nil
}

{{ if not .IsSetting }}
func (c *Client) delete{{ .StructName }}(ctx context.Context, site, id string) error {
	err := c.do(ctx, "DELETE", fmt.Sprintf("s/%s/rest/{{ .ResourcePath }}/%s", site, id), struct{}{}, nil)
	if err != nil {
		return err
	}
	return nil
}

func (c *Client) create{{ .StructName }}(ctx context.Context, site string, d *{{ .StructName }}) (*{{ .StructName }}, error) {
	var respBody struct {
		Meta meta      `json:"meta"`
		Data []{{ .StructName }} `json:"data"`
	}

	err := c.do(ctx, "POST", fmt.Sprintf("s/%s/rest/{{ .ResourcePath }}", site), d, &respBody)
	if err != nil {
		return nil, err
	}

	if len(respBody.Data) != 1 {
		return nil, &NotFoundError{}
	}

	new := respBody.Data[0]

	return &new, nil
}
{{- end }}

func (c *Client) update{{ .StructName }}(ctx context.Context, site string, d *{{ .StructName }}) (*{{ .StructName }}, error) {
	var respBody struct {
		Meta meta      `json:"meta"`
		Data []{{ .StructName }} `json:"data"`
	}
{{ if .IsSetting }}
	d.Key = "{{ .ResourcePath }}"
	err := c.do(ctx, "PUT", fmt.Sprintf("s/%s/set/setting/{{ .ResourcePath }}", site), d, &respBody)
{{- else }}
	err := c.do(ctx, "PUT", fmt.Sprintf("s/%s/rest/{{ .ResourcePath }}/%s", site, d.ID), d, &respBody)
{{- end }}
	if err != nil {
		return nil, err
	}

	if len(respBody.Data) != 1 {
		return nil, &NotFoundError{}
	}

	new := respBody.Data[0]

	return &new, nil
}
